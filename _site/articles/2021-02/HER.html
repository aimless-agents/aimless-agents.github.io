<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Hindsight is 2020 | aimless agents</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Hindsight is 2020" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Experiments in goal-conditioned learning." />
<meta property="og:description" content="Experiments in goal-conditioned learning." />
<link rel="canonical" href="http://localhost:4000/articles/2021-02/HER" />
<meta property="og:url" content="http://localhost:4000/articles/2021-02/HER" />
<meta property="og:site_name" content="aimless agents" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-11T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hindsight is 2020" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/articles/2021-02/HER"},"datePublished":"2021-02-11T00:00:00-05:00","url":"http://localhost:4000/articles/2021-02/HER","@type":"BlogPosting","description":"Experiments in goal-conditioned learning.","headline":"Hindsight is 2020","dateModified":"2021-02-11T00:00:00-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=c41bacf904699970d674c45c7836a7df21207bec">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">aimless agents</a></h1>
      

      <ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ul>
      <li><a href="#what-is-td3" id="markdown-toc-what-is-td3">What is TD3?</a></li>
      <li><a href="#what-is-her" id="markdown-toc-what-is-her">What is HER?</a></li>
      <li><a href="#why-td3--her" id="markdown-toc-why-td3--her">Why TD3 + HER?</a></li>
    </ul>
  </li>
  <li><a href="#setup" id="markdown-toc-setup">Setup</a>    <ul>
      <li><a href="#fetchreach-environment" id="markdown-toc-fetchreach-environment">FetchReach Environment</a></li>
      <li><a href="#sparsified-reacher-environment" id="markdown-toc-sparsified-reacher-environment">Sparsified Reacher Environment</a></li>
    </ul>
  </li>
  <li><a href="#results" id="markdown-toc-results">Results</a>    <ul>
      <li><a href="#fetchreach-environment-results" id="markdown-toc-fetchreach-environment-results">FetchReach Environment Results</a></li>
      <li><a href="#sparsified-reacher-environment-results" id="markdown-toc-sparsified-reacher-environment-results">Sparsified Reacher Environment Results</a></li>
    </ul>
  </li>
  <li><a href="#takeaways" id="markdown-toc-takeaways">Takeaways</a></li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
  <li><a href="#resources" id="markdown-toc-resources">Resources</a>    <ul>
      <li><a href="#papers" id="markdown-toc-papers">Papers</a></li>
      <li><a href="#other-resources" id="markdown-toc-other-resources">Other Resources</a></li>
    </ul>
  </li>
  <li><a href="#appendix" id="markdown-toc-appendix">Appendix</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This past semester we took a <a href="https://cmudeeprl.github.io/403_website/" target="_blank">deep reinforcement learning course</a> together at CMU. The class introduced us to goal-conditioned learning and  <strong>Hindsight Experience Replay (HER)</strong>. The underlying concepts behind HER interested us, and we wanted to try reproducing the authors’ results in sparse/binary reward environments - in our case, simulated reacher environments - benchmarked against vanilla TD3. We hope to illustrate the benefits of using hindsight experience in sparse, binary reward environments through sharing a discussion of <a href="https://github.com/aimless-agents/TD3" target="_blank">our implementation</a>, experimentation, and methods. While we won’t go in-depth into the implementation details, we hope that you come out of this with a better idea of why hindsight replay is so useful and interesting, and how we went about trying to prove it!</p>

<h3 id="what-is-td3">What is TD3?</h3>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/td3_spiderman.png" alt="An illustration of how TD3 works." />
    <p><figcaption><i>An illustration of how TD3 works.</i></figcaption></p>
    
    </figure>
</div>

<p><a href="https://arxiv.org/abs/1802.09477" target="_blank">TD3</a> is an off-policy RL method for continuous action spaces, which improves its predecessor, <a href="https://arxiv.org/abs/1509.02971" target="_blank">DDPG</a>, by reducing overestimation bias and improving training stability. This generally results in higher performance than DDPG. We’re going to assume we all have a working knowledge of RL algorithms, but if you want to learn more then you can read more details about TD3 and DDPG <a href="https://towardsdatascience.com/td3-learning-to-run-with-ai-40dfc512f93" target="_blank">here</a>.</p>

<h3 id="what-is-her">What is HER?</h3>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="https://i.pinimg.com/originals/b7/f6/f4/b7f6f409e68715245296a33ef5452b3c.gif" alt="Some good questions from our good man Michael Bluth." />
    <p><figcaption><i>Some good questions from our good man Michael Bluth.</i></figcaption></p>
    
    </figure>
</div>

<p>To understand <a href="https://arxiv.org/abs/1707.01495" target="_blank">HER</a>, you’ll first need to understand <strong>regular experience replay (ER)</strong>. ER involves learning from an agent’s memory, by storing past experiences (more specifically, transitions) in a replay buffer. Then, the agent trains on randomly sampled transitions from the replay buffer by “replaying” these transitions. Training on randomly sampled transitions rather than sequentially collected experience helps de-correlate training data and improves learning. You can learn more about it <a href="https://www.youtube.com/watch?v=Bcuj2fTH4_4&amp;t=138s&amp;ab_channel=deeplizard" target="_blank">here</a>.</p>

<p><strong>Goal-conditioned learning</strong> generally means learning to reach a goal <em>in addition to</em> maximizing reward. Let’s illustrate this with a motivating example:</p>

<p>A soccer player successfully kicks the ball into the goal - this is obviously a helpful learning example, as the player learns to repeat their sequence of actions to achieve their goal. But what about if the ball lands, say, a foot away from the goalpost? We can “move” the goalpost to wherever the ball actually ended up, so the player learns to celebrate making goals rather than feeling sad that they did not make the original goal. This helps the soccer player learn how to score better overall.</p>

<p>HER leverages this concept by augmenting real experience collected for the replay buffer with hindsight about states the agent was actually able to reach. For example, let’s say Turtle Claire is trying to make a goal. If the goal is 3 cells away, traditional goal-conditioned experience replay would tell her to store each of these transitions in her replay buffer with the original goal state at cell 3 and no return (AKA a cumulative reward of 0), since she did not score a goal.</p>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/sadsoccerturtle.png" alt="Turtle Claire tried to score a goal but didn't make it. This makes her feel sad." />
    <p><figcaption><i>Turtle Claire tried to score a goal but didn't make it. This makes her feel sad.</i></figcaption></p>
    
    </figure>
</div>

<p>But with HER, Turtle Claire would also store each of these transitions with a goal state of cell 2 and positive return, since she would have scored had the goal been in cell 2. Even though this is not the original goal we wanted to achieve, we are still able to learn something useful by “moving the goalposts” in hindsight, which is the crux of HER.</p>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/happysoccerturtle.png" alt="In hindsight, Turtle Claire knows that if the goal had been in cell 2, then she would have made a goal. This makes her happier!" />
    <p><figcaption><i>In hindsight, Turtle Claire knows that if the goal had been in cell 2, then she would have made a goal. This makes her happier!</i></figcaption></p>
    
    </figure>
</div>

<p>HER and goal-conditioned methods aim to solve the issue of learning in an environment with <strong>sparse rewards</strong>, which means very few states/actions in the environment actually give a positive or non-zero reward signal. Often, these sparse rewards are <strong>binary</strong>, as in Turtle Claire’s soccer scenario: you have either scored a goal, or you have not.</p>

<p>HER also helps with <strong>sample efficiency</strong>: since we augment our experience buffer with these goal-conditioned examples for replay, we have access to far more training data while using the same amount of examples drawn from the environment.</p>

<h3 id="why-td3--her">Why TD3 + HER?</h3>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/td3hermovie.png" alt="A romance for the epochs." />
    <p><figcaption><i>A romance for the epochs.</i></figcaption></p>
    
    </figure>
</div>

<p>If you read the HER paper, you’ll notice that the authors implemented HER with DDPG. We were wondering why they didn’t use TD3 instead, given that it’s a marked improvement on DDPG. After some digging, we found out that the HER paper came out one year before Fujimoto published his paper introducing TD3, which was a nice reminder of how quickly the field moves!</p>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/sotagrandma.png" alt="It can be difficult to keep up sometimes..." />
    <p><figcaption><i>It can be difficult to keep up sometimes...</i></figcaption></p>
    
    </figure>
</div>

<p>At any rate, poking around on <a href="https://paperswithcode.com/paper/hindsight-experience-replay" target="_blank">Papers With Code</a> and Google yielded re-implementations of the DDPG + HER results from the original paper. Although we did find some implementations of TD3+HER out there (like <a href="https://arxiv.org/pdf/2010.06142.pdf" target="_blank">this</a>, <a href="https://journals.sagepub.com/doi/full/10.1177/1729881419898342" target="_blank">this</a>, and <a href="https://github.com/hill-a/stable-baselines" target="_blank">this</a>), our curiosity was sufficiently piqued by TD3 and HER that we wanted to do our own exploration of it.</p>

<p>Specifically, we wanted to see what would happen if we trained our agents using TD3 with HER, instead of standard ER (which TD3 was originally proposed with). Even though TD3 tends to perform better than DDPG by improving stability and reducing overestimation bias during training, we expect that it won’t be able to overcome difficulties with learning in sparse reward environments. This is where HER comes in.</p>

<h2 id="setup">Setup</h2>

<p>We started with Fujimoto’s <a href="https://github.com/sfujim/TD3" target="_blank">original TD3 implementation</a> and added hindsight replay functionality on top of it. For more details, you can see our code <a href="https://github.com/clairecw/TD3" target="_blank">here</a>.</p>

<p>Our goal was to train the agent in two different variations of a sparse-reward environment: OpenAI’s <a href="https://gym.openai.com/envs/FetchReach-v1/" target="_blank">FetchReach environment</a> (designed for learning sparse reward), and a sparsification of OpenAI’s <a href="https://gym.openai.com/envs/Reacher-v2/" target="_blank"> MuJoCo Reacher environment</a> (a dense reward environment that we adapted into a sparse reward environment).</p>

<p>For both environments, we evaluated the corresponding robot arm’s performance trained on:</p>

<ul>
  <li>vanilla TD3 in a sparse reward environment, which we will refer to as the <strong><em>Sparse TD3</em></strong> agent</li>
  <li>TD3 + HER in a sparse reward environment, which we will refer to as the <strong><em>TD3+HER</em></strong> agent</li>
  <li>vanilla TD3 in a dense reward environment, which we will refer to as the <strong><em>Dense TD3</em></strong> agent</li>
</ul>

<p>We will describe the environments in more detail below.</p>

<h3 id="fetchreach-environment">FetchReach Environment</h3>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/fetchreach_random.gif" alt="Agent in FetchReach environment taking random actions." />
    <p><figcaption><i>Agent in FetchReach environment taking random actions.</i></figcaption></p>
    
    </figure>
</div>

<p>There is an <a href="https://openai.com/blog/ingredients-for-robotics-research/" target="_blank">awesome suite of sparse reward environments</a> designed by <a href="https://openai.com/" target="_blank">OpenAI</a> that work with HER already that were benchmarked on <a href="https://arxiv.org/abs/1802.09464" target="_blank">DDPG + HER</a>.</p>

<p>This environment is arguably the simplest of this suite of sparse reward environments that OpenAI released. The goal of this environment is to control a 3 degree-of-freedom robotic arm to reach a block placed before it in 3D space. The block’s location is fixed throughout the <strong>episode</strong> (where an “episode” is one attempt to reach the goal, capped out at 50 timesteps), but is randomly generated at the start of each episode.</p>

<p>This environment is default-set to return a sparse reward: it will give a reward \(r_t\) of 0 at timestep \(t\) if the block is within \(\epsilon\) of goal state \(g\) after taking action \(a\) from state \(s\), and 0 reward if it is not:</p>

\[r_t(s, a, g) = \left\{\begin{array}{ll}
0 &amp; d(s, g) &lt; \epsilon\\
-1 &amp; \text{otherwise}
\end{array}
\right.\]

<p>The <strong>return</strong> \(R\) of one episode in the FetchReach environment is the cumulative reward over each timestep in the episode:</p>

\[R = \sum_t r_t\]

<p>How do these formulas correspond to getting the robot arm to reach as close to the target block as possible? If we received an episode return \(R = -50\), this would imply that our robot arm was  not within \(\epsilon\) of the block, or any goal state, throughout the entire episode. That’s not what we want! On the other hand, if we received an episode return \(R = 0\), this means that at every timestep in our episode, the robot arm was within \(\epsilon\) of the block, or any goal state, throughout the entire episode. This <em>is</em> what we want! Therefore, we want to train our TD3 agent to maximize cumulative reward and achieve close to 0 episode return.</p>

<h3 id="sparsified-reacher-environment">Sparsified Reacher Environment</h3>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/crrandom.gif" alt="Agent in Reacher environment taking random actions." />
    <p><figcaption><i>Agent in Reacher environment taking random actions.</i></figcaption></p>
    
    </figure>
</div>

<p>The Reacher-v2 OpenAI Gym environment is similar to FetchReach in that a robot arm must reach a goal object. However, it has a shaped reward function that includes distance to the goal object, as well as a reward penalty for extraneous robot arm movement, and only has two degrees of freedom. In addition, this environment is considered “solved” (i.e. the robot arm has reached the goal object) when the episode return is greater than -3.75.</p>

<p>OpenAI’s FetchReach environment was made <em>specifically</em> to benchmark goal-conditioned learning strategies, so we wanted to challenge our implementation to see if it could still solve an environment that wasn’t “born” to be sparse. Therefore, we figured that the Reacher-v2 OpenAI Gym environment, which has a similar goal to the FetchReach environment but was designed with a shaped reward signal in mind, would be a good candidate for sparsification. Therefore, we extended the MuJoCo Reacher environment in order to convert it to a sparse reward environment.</p>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/borntobesparse.png" alt="Some environments were born to be sparse." />
    <p><figcaption><i>Some environments were born to be sparse.</i></figcaption></p>
    
    </figure>
</div>

<p>The main changes we made to the original Bullet environment were:</p>
<ul>
  <li><strong>Sparsifying the environment:</strong> the agent only gets a reward if it’s within some distance \(\epsilon\) of the target location, otherwise 0.</li>
  <li><strong>Augment the existing standard replay buffer with the agent’s intended goal and goal-conditioned rewards.</strong> We used the HER authors’ “future” goal-choosing scheme, which means after each episode, a state \(s\) selected for hindsight replay would be stored with its goal being a uniform-randomly selected state that occurred <em>after</em> \(s\) in the episode.</li>
</ul>

<p>Some prominent variations to the reward definition and HER training we tried were:</p>
<ul>
  <li>Varying \(\epsilon\), or how “off” the agent can be from the goal and still receive reward for “achieving” the goal.</li>
  <li>Varying \(k\), the ratio of standard ER and HER-generated memory to store for replay.</li>
  <li>Including/excluding factors other than distance to goal in the reward function.</li>
</ul>

<p>See the Appendix for a full description of these parameters, along with additional things we varied.</p>

<h2 id="results">Results</h2>

<h3 id="fetchreach-environment-results">FetchReach Environment Results</h3>

<figure class="image" style="width: 80%; margin: auto;">
    <div class="image-row">
        
            <img class="image" src="/img/her/fetchreach_random.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Clearly, the TD3+HER agent (3rd agent from the left) performs the best." />
        
            <img class="image" src="/img/her/fetchreach_vanillatd3.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Clearly, the TD3+HER agent (3rd agent from the left) performs the best." />
        
            <img class="image" src="/img/her/fetchreach_her.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Clearly, the TD3+HER agent (3rd agent from the left) performs the best." />
        
            <img class="image" src="/img/her/fetchreach_dense.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Clearly, the TD3+HER agent (3rd agent from the left) performs the best." />
        
    </div>
    <p><figcaption><i>From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Clearly, the TD3+HER agent (3rd agent from the left) performs the best.</i></figcaption></p>
</figure>

<p>The verdict is in: including hindsight experience drastically improved the robot arm’s ability to reach the block! We can see that over 1 million timesteps, the poor sparse TD3 robot arm is unable to learn to reach the block at all. However, with HER, the TD3 + HER robot arm is able to consistently reach the block and achieve close to 0 episode returns within 200k timesteps.</p>

<div class="justify-content-center flex">
    <figure class="image">
    <img src="/img/her/fetchreachrewards.png" alt="We can see that while Sparse TD3 (blue) fails to learn in this binary reward environment, TD3+HER (green) is able to achieve good performance in under 100k timesteps. It is also the closest to achieving near-zero episode returns out of all the agents, including the TD3 agent trained in a dense reward environment (red). Shaded regions illustrate the standard deviation over 10 evaluation episodes." />
    <p><figcaption><i>We can see that while Sparse TD3 (blue) fails to learn in this binary reward environment, TD3+HER (green) is able to achieve good performance in under 100k timesteps. It is also the closest to achieving near-zero episode returns out of all the agents, including the TD3 agent trained in a dense reward environment (red). Shaded regions illustrate the standard deviation over 10 evaluation episodes.</i></figcaption></p>
    
    </figure>
</div>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Vanilla TD3 Agent <br /> (Sparse Reward)</th>
      <th>TD3 + HER Agent<br />(Sparse Reward)</th>
      <th>Vanilla TD3 Agent <br />(Dense Reward)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(\epsilon\) = 0.05</td>
      <td>10%</td>
      <td>100%</td>
      <td>5%</td>
    </tr>
  </tbody>
</table>

<p class="centered"><i>Using an epsilon of 0.05, the TD3 + HER agent successfully reached the goal 100% of the time. Meanwhile, the vanilla TD3 agent trained in a sparse reward environment only reached the goal 10% of the time.</i></p>

<p>Interestingly, the dense TD3 agent was unable to solve the environment. Its reward may be higher than that of sparse TD3 agent based on the plot above, but playing the recording back shows that it doesn’t appear to perform much better than the sparse TD3 agent.</p>

<h3 id="sparsified-reacher-environment-results">Sparsified Reacher Environment Results</h3>

<figure class="image" style="width: 80%; margin: auto;">
    <div class="image-row">
        
            <img class="image" src="/img/her/crrandom.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Although the dense TD3 agent (rightmost) performs the best, the TD3+HER agent performs significantly better than the random agent." />
        
            <img class="image" src="/img/her/crsparse.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Although the dense TD3 agent (rightmost) performs the best, the TD3+HER agent performs significantly better than the random agent." />
        
            <img class="image" src="/img/her/crher.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Although the dense TD3 agent (rightmost) performs the best, the TD3+HER agent performs significantly better than the random agent." />
        
            <img class="image" src="/img/her/crdense.gif" alt="From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Although the dense TD3 agent (rightmost) performs the best, the TD3+HER agent performs significantly better than the random agent." />
        
    </div>
    <p><figcaption><i>From left to right: random agent, sparse TD3 agent, TD3+HER agent, and dense TD3 agent. Although the dense TD3 agent (rightmost) performs the best, the TD3+HER agent performs significantly better than the random agent.</i></figcaption></p>
</figure>

<p>Although our sparsified environment was more difficult to solve than the FetchReach environment we had initially benchmarked, we were still able to perform far better than the sparse TD3 agent, which you can see above.</p>

<p>The best settings for the parameters listed in the <a href="#sparsified-reacher-environment">Sparsified Reacher Environment section</a> are:</p>

<ul>
  <li>a linearly annealed \(\epsilon\) from 0.07 to 0.05</li>
  <li>storing a mixture of hindsight and regular experience</li>
  <li>using a -1/0 binary reward signal based on both distance to goal and action magnitude</li>
</ul>

<p>We tracked the returns from our binary reward function, but we also computed the original returns under the environment’s original <strong>shaped reward</strong> (i.e. non-sparse, non-binary reward) to get a sense of how well our agent performed in the sparsified reacher environment. We can see that although the TD3+HER agent does not perform as well as the dense TD3 agent, it performs far better than the sparse TD3 agent. So, while the agent isn’t able to surpass the original “solved” reward threshold or match the performance in the original environment, it is clearly still able to learn something useful!</p>

<figure class="image" style="width: 80%; margin: auto;">
    <div class="image-row">
        
            <img class="image" src="/img/her/customreacherrewards.png" alt="We can see that the agent trained on HER + TD3 learns over time with respect to the binary reward function (left). Validating our agent with respect to the original shaped reward function (right) shows that the TD3 + HER agent does, in fact, perform far better than the agent trained on vanilla TD3 with a binary reward function." />
        
            <img class="image" src="/img/her/customreacheroriginalrewards.png" alt="We can see that the agent trained on HER + TD3 learns over time with respect to the binary reward function (left). Validating our agent with respect to the original shaped reward function (right) shows that the TD3 + HER agent does, in fact, perform far better than the agent trained on vanilla TD3 with a binary reward function." />
        
    </div>
    <p><figcaption><i>We can see that the agent trained on HER + TD3 learns over time with respect to the binary reward function (left). Validating our agent with respect to the original shaped reward function (right) shows that the TD3 + HER agent does, in fact, perform far better than the agent trained on vanilla TD3 with a binary reward function.</i></figcaption></p>
</figure>

<p>As we mentioned earlier, our best-performing TD3+HER agent was trained on an \(\epsilon\) linearly annealed from 0.07 to 0.05. When we benchmarked the final trained agent on our starting epsilon of 0.07, we discovered that it reached the goal 60% of the time. Meanwhile, benchmarking the final trained agent on our ending epsilon of 0.05 demonstrated that the agent reached the goal 50% of the time. Not sure about you, but we’d take those odds over the TD3 agent trained in a sparse reward environment any day of the week!</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Vanilla TD3 Agent <br /> (Sparse Reward)</th>
      <th>TD3 + HER Agent<br />(Sparse Reward)</th>
      <th>Vanilla TD3 Agent <br />(Dense Reward)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(\epsilon\) = 0.07</td>
      <td>0%</td>
      <td>60%</td>
      <td>100%</td>
    </tr>
    <tr>
      <td>\(\epsilon\) = 0.05</td>
      <td>0%</td>
      <td>50%</td>
      <td>100%</td>
    </tr>
  </tbody>
</table>

<p class="centered"><i>Given the starting and ending epsilons we trained on, the TD3 + HER agent was able to reach the goal 50-60% of the time. Meanwhile, the vanilla TD3 agent trained in a sparse reward environment was never able to reach the goal for either epsilon, and the agent trained in the dense reward environment was always able to reach the goal for either epsilon.</i></p>

<h2 id="takeaways">Takeaways</h2>

<ul>
  <li>
    <p><strong>Varying Epsilon:</strong> When defining our sparsified Reacher environment, the \(\epsilon\) determining the reward threshold played a large role in the agent’s learning - too large and the agent would too easily be within \(\epsilon\) of the goal and start to jitter around that area. Too small and even the goal-conditioned rewards would be too sparse for a HER agent to learn at all.</p>
  </li>
  <li>
    <p><strong>Parameters:</strong> In general (as is the case with any deep learning agent), we had lots of parameters to tune. Many of these (including \(\epsilon\)) arose from the fact that we were trying to modify an existing environment to get a binary reward function; the rest were mostly due to possible variations on HER implementations.</p>
  </li>
  <li>
    <p><strong>Sparsifying the Environment:</strong> HER was surprisingly effective at reaching the goal in a large percentage of episodes!</p>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>As our first (but hopefully not last) collab, we were super happy that our modifications to a SOTA algorithm achieved solid performance in binary, sparse-reward environments. We’re particularly excited that even after manually introducing reward sparsity to increase an environment’s difficulty, our agent still learned reasonably well, which confirmed our original hopes that introducing HER would significantly improve the learning achievable by TD3 alone. If you like, you can check out our code <a href="https://github.com/aimless-agents/TD3" target="_blank">here</a>! 🤪</p>

<p>We were initially drawn to goal-conditioned learning because it proves that even though you can’t achieve your loftier goals right now, there is intrinsic value in striving to achieve reachable goals in the present: you might learn something that helps you become successful in the future! Being able to prove this life lesson with an RL agent made this project extra satisfying for us.</p>

<p>If you have any questions, comments, or doubts, feel free to reach out to us via email, or drop your response below! This is a learning experience for us and we would love to receive feedback on how we could improve.</p>

<h2 id="resources">Resources</h2>

<p>A huge, HUGE shoutout to Alex LaGrassa and Shreyas Chaudhari, who helped guide us at different parts throughout this entire journey.</p>

<p>In addition, we referenced a lot of great materials throughout the blogpost and while we were learning more about TD3 and HER! While these lists may not be exhaustive of all of that material, we hope that it is representative of it, and can be of use to someone else.</p>

<h3 id="papers">Papers</h3>

<p>[1] Marcin Andrychowicz, et al. <a href="https://arxiv.org/abs/1707.01495" target="_blank">Hindsight Experience Replay</a> (2018).</p>

<p>[2] Timothy P. Lillicrap, et al. <a href="https://arxiv.org/abs/1509.02971" target="_blank">Continuous control with deep reinforcement learning</a> (2019).</p>

<p>[3] Scott Fujimoto, et al. <a href="https://arxiv.org/abs/1802.09477" target="_blank">Addressing Function Approximation Error in Actor-Critic Methods</a> (2018).</p>

<p>[4] Matthias Plappert, et al. <a href="https://arxiv.org/abs/1802.09464" target="_blank">Multi-Goal Reinforcement Learning: Challenging Robotics Environments and Request for Research</a> (2018).</p>

<p>[5] Dhuruva Priyan G M, et al. <a href="https://arxiv.org/abs/2010.06142" target="_blank">Hindsight Experience Replay with Kronecker Product Approximate Curvature</a>. (2020).</p>

<h3 id="other-resources">Other Resources</h3>

<ul>
  <li>
    <p><a href="https://cmudeeprl.github.io/403_website/" target="_blank">Deep RL @ CMU</a></p>
  </li>
  <li>
    <p><a href="https://towardsdatascience.com/td3-learning-to-run-with-ai-40dfc512f93" target="_blank">TD3: Learning to Run With AI</a></p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=Bcuj2fTH4_4&amp;t=138s&amp;ab_channel=deeplizard" target="_blank">Replay Memory Explained</a></p>
  </li>
  <li>
    <p><a href="https://paperswithcode.com/paper/hindsight-experience-replay" target="_blank">Papers With Code: HER</a></p>
  </li>
  <li>
    <p><a href="https://github.com/hill-a/stable-baselines" target="_blank">Stable Baselines</a></p>
  </li>
  <li>
    <p><a href="https://github.com/sfujim/TD3" target="_blank">Fujimoto’s Original TD3 Implementation</a></p>
  </li>
  <li>
    <p><a href="https://gym.openai.com/envs/FetchReach-v1/" target="_blank">FetchReach Environment</a></p>
  </li>
  <li>
    <p><a href="https://gym.openai.com/envs/Reacher-v2/" target="_blank">Reacher Environment</a></p>
  </li>
  <li>
    <p><a href="https://openai.com/blog/ingredients-for-robotics-research/" target="_blank">OpenAI: Ingredients for Robotics Research</a></p>
  </li>
</ul>

<h2 id="appendix">Appendix</h2>

<p>The following is the full set of parameters for our sparsified Reacher experiments we performed:</p>

<ul>
  <li>Varying \(\epsilon\) (the “threshold” maximum distance to goal at which the agent is rewarded).
    <ul>
      <li>We also tried various annealing methods to decrease \(\epsilon\) over time, to try to nudge the agent closer and closer to the goal:
        <ul>
          <li>Linear: \(\epsilon\) decrease by a fixed amount each episode</li>
          <li>Exponential: \(\epsilon\) decreased according to an exponential curve</li>
          <li>Step-wise: every x episodes would use a different \(\epsilon\)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Using Euclidean distance vs. each element-wise distance to measure goal proximity.</li>
  <li>Varying reward magnitudes (e.g., 0.1 vs. 1 for positive reward).</li>
  <li>Instead of positive reward, using a reward “penalty” for not reaching goal (0 reward if target reached, else -1).</li>
  <li>Varying the \(k\) parameter from the original HER paper, which controls the ratio of HER-selected vs. standard goal-conditioned ER replay memories.</li>
  <li>Storing both a standard ER and HER-generated memory for each transition (instead of using \(k\) above). In the original paper, for any given episode, \(\frac{k}{k+1}\) transitions would be stored with a HER-selected goal, and the rest are stored with the original intended goal. Here, we also tried storing all transitions with the original goal <em>and</em> a HER-selected goal.</li>
  <li>Electricity cost threshold: the agent only gets a reward for reaching the goal <em>and</em> if it doesn’t exceed this electricity threshold.</li>
</ul>

<p>It’s also worth noting that we initially tried sparsifying the <a href="https://github.com/benelot/pybullet-gym#state-of-implementations" target="_blank">Pybullet reimplementation</a> of MuJoCo Reacher, since we wanted to be able to train without a MuJoCo license. However, we found that the MuJoCo environment was much more amenable to learning over time and ultimately chose to extend the MuJoCo environment instead.</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/aimless-agents/aimless-agents.github.io/edit/gh-pages/_posts/her/2021-02-11-HER.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'G-E2VY99JNJM', 'auto');
      ga('send', 'pageview');
    </script>
    
  </body>
</html>
